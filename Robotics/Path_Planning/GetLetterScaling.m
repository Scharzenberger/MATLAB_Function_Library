function [ Scl ] = GetLetterScaling( Ps_Plane, T_Plane, Lpts )
%% Function Description.

%This function takes in plane points, the plane's orientation, and the points of a template letter.  It uses this information to produce a scaling matrix that scales the letter to be within the triangle formed by the plane points.

%% Define the Default Settings.

%Set up a variable to store the line points.
P_lines = [];

%% Compute the Widths of the Letter Template.
%Compute the maximum and minimum x & y values in the letter.
[Lpts_max, Lpts_min] = deal( max(Lpts, [], 2), min(Lpts, [], 2) );

%Compute the width of the letter.
W_Letter = Lpts_max - Lpts_min;

%Retrieve the x & y directional widths.
W_Letter = W_Letter(1:2);

%Compute the radius of the letter.
Lr = max(vecnorm(Lpts));

%% Transform the Plane Points into the Template Letter Space.

%Get the rotational component of the plane orientation.
R = TransMatrix2Rp( T_Plane );

%Compute the locations of the plane points in the plane's frame.
nPs_Plane = R\Ps_Plane;

%Compute the centroid location for the triangle who's vertices are the three points defining the plane.
[nx_centroid, ny_centroid, nz_centroid] = deal( mean(nPs_Plane(1, :)), mean(nPs_Plane(2, :)), mean(nPs_Plane(3, :)) );

%Define the centroid as a column vector.
nP_centroid = [nx_centroid ny_centroid nz_centroid]';

%Compute the location of the points relative to the centriod.
nPs_plane_rel = nPs_Plane - nP_centroid;

%Set the relative plane points.
nPs_plane_rel = CenterLetter(nPs_plane_rel);


%% Compute the Scaling Factor to Remain in Bounds (Rectangle Method).

%Compute the maximum and minimum x & y values in the plane.
[nPs_plane_rel_max, nPs_plane_rel_min] = deal( max(nPs_plane_rel, [], 2), min(nPs_plane_rel, [], 2) );

%Compute the width of the letter.
W_Plane = nPs_plane_rel_max - nPs_plane_rel_min;

%Retrieve the x & y directional widths.
W_Plane = W_Plane(1:2);

%Compute the Ratio of the Plane and Word Widths.
rs = W_Plane./W_Letter;

%Compute the scaling factor.
% scl = 1.4*min(rs);
% scl = 1*min(rs);

[sclx, scly] = deal( rs(1), rs(2) );
% [sclx, scly] = deal( 2.1*rs(1), 0.9*rs(2) );

%Define a scaling matrix.
% Scl = [scl 0 0 0; 0 scl 0 0; 0 0 1 0; 0 0 0 1];
Scl = [sclx 0 0 0; 0 scly 0 0; 0 0 1 0; 0 0 0 1];


%% Compute the Scaling Factor to Remain in Bounds (Triangle Method).
% 
% %Initialize counters for the upcoming while loop.
% [loc1, loc2] = deal( 0 );
% 
% %Preallocate arrays to store the bounds generated by the triangle points.
% ds = -1*ones( 1, nchoosek( size(nPs_plane_rel, 2), 2 ) );
% 
% %Define the critical point for determining the minimum radius of the triangle.
% P_crit = [0 0]';
% 
% %Compute the polynomial coefficient vectors associated with each edge line of the triangle formed by the transformed plane points.
% while loc1 < (size(nPs_plane_rel, 2) - 1)          %Iterate one less time than the total number of points to consider... (i.e, iterate through each line).
%     %Advance the first counter.
%     loc1 = loc1 + 1;
%     
%     %Extract the first point from the transformed plane points.
%     P1_crit = nPs_plane_rel(1:2, loc1);
%     
%     %Compute the polynomial coefficient vectors.
%     for k = (loc1 + 1):size(nPs_plane_rel, 2)        %Iterate through each pair of points...
%         
%         %Advance the second counter.
%         loc2 = loc2 + 1;
%         
%         %Extract the second point from the transformed plane points.
%         P2_crit = nPs_plane_rel(1:2, k);
%         
%         %Extract the x & y values associated with these points.
%         [xs_crit, ys_crit] = deal( [P1_crit(1) P2_crit(1)]', [P1_crit(2) P2_crit(2)]' );
%         
%         %Create the system matrix.
%         A = [xs_crit ones(size(xs_crit, 1), 1)];
%         
%         %Compute the associated polynomial coefficient vector.
%         rho = A\ys_crit;
%         
%         %Determine how to compute the nearest line point.
%         if rho(1) == 0                          %If the current line is horizonal...
%             P_line = [P_crit(1) rho(2)]';       %Project the critical points x value onto the horizontal line for the x value and take the height of the horizontal line as the y value.
%         elseif isinf(rho(1))                    %If the current line is vertical...
%             P_line = [xs_crit(1) P_crit(2)]';       %Project the critical points y value onto the vertical line for the y value and take the position of the vertical line as the x value.
%         else                                    %Otherwise use the standard computation procedure.
%             %Define the system matrix.
%             B = [-rho(1) 1; 1/rho(1) 1];
%             
%             %Define the applied vector.
%             C = [rho(2); P_crit(2) + (1/rho(1))*P_crit(1)];
%             
%             %Compute the nearest point on the current line.
%             P_line = B\C;
%         end
%         
%         %Store the line points.
%         P_lines = cat(2, P_lines, P_line);
%         
%         %Compute the distance between the current point and the nearest point on the current line.
%         ds(loc2) = norm(P_line - P_crit);
%         
%     end
% end
% 
% %Compute the minimum radius of the triangle.
% Tr = min(ds);
% 
% %Determine the x & y scaling ratios.
% scl = Tr/Lr;
% 
% %Define the approperiate scaling matrix.
% Scl = [scl 0 0 0; 0 scl 0 0; 0 0 1 0; 0 0 0 1];

%% Plot the results to troubleshoot.

% %Scale the letter points.
% nLpts = Scl(1:3, 1:3)*Lpts;
% 
% %Format a figure to store the graphical information.
% figure, hold on, grid on, axis equal, rotate3d on
% xlabel('x-Axis'), ylabel('y-Axis'), zlabel('z-Axis')
% 
% %Plot the original letter template.
% plot3(Lpts(1, :), Lpts(2, :), Lpts(3, :), '.-', 'Markersize', 20)
% 
% %Plot the scaled letter template.
% plot3(nLpts(1, :), nLpts(2, :), nLpts(3, :), '.-', 'Markersize', 20)
% 
% %Plot the plane points in their frame.
% plot3([nPs_plane_rel(1, :) nPs_plane_rel(1, 1)], [nPs_plane_rel(2, :) nPs_plane_rel(2, 1)], [nPs_plane_rel(3, :) nPs_plane_rel(3, 1)], '.-', 'Markersize', 20)

%Plot the nearest line points.
% plot(P_lines(1, :), P_lines(2, :), '.', 'Markersize', 20)

%Add a legend to the plot
% legend('Original Letter', 'Scaled Letter', 'Boundary', 'Plane Points')

end

